<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-big-counter.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"locallhost","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="线程安全概述引用《Java Concurrency In Practice》对线程安全的定义  当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  这意味着如若要实现线程安全，代码本身必须要封装所有必要的正确性保障手段（比如锁的实现），以确保程序">
<meta property="og:type" content="article">
<meta property="og:title" content="Java线程同步策略">
<meta property="og:url" content="locallhost/2017/06/17/java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/index.html">
<meta property="og:site_name" content="MerlinFeng&#39;s blog">
<meta property="og:description" content="线程安全概述引用《Java Concurrency In Practice》对线程安全的定义  当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。  这意味着如若要实现线程安全，代码本身必须要封装所有必要的正确性保障手段（比如锁的实现），以确保程序">
<meta property="og:locale">
<meta property="article:published_time" content="2017-06-17T14:42:41.000Z">
<meta property="article:modified_time" content="2020-08-19T09:05:56.735Z">
<meta property="article:author" content="FengQiang">
<meta property="article:tag" content="JAVA">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="locallhost/2017/06/17/java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-Hans'
  };
</script>

  <title>Java线程同步策略 | MerlinFeng's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">MerlinFeng's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">MerlinFeng's blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="locallhost/2017/06/17/java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="FengQiang">
      <meta itemprop="description" content="面向接口编程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="MerlinFeng's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java线程同步策略
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2017-06-17 22:42:41" itemprop="dateCreated datePublished" datetime="2017-06-17T22:42:41+08:00">2017-06-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-08-19 17:05:56" itemprop="dateModified" datetime="2020-08-19T17:05:56+08:00">2020-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JAVA/" itemprop="url" rel="index"><span itemprop="name">JAVA</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>引用《Java Concurrency In Practice》对线程安全的定义</p>
<blockquote>
<p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p>
</blockquote>
<p>这意味着如若要实现线程安全，代码本身必须要封装所有必要的正确性保障手段（比如锁的实现），以确保程序无论在多线程环境下如何调用该方法，将始终保持返回正确的结果。</p>
<h2 id="Java的线程安全"><a href="#Java的线程安全" class="headerlink" title="Java的线程安全"></a>Java的线程安全</h2><p>我们在讨论Java的线程安全，实际上讨论的是“相对线程安全”。需要保证的是单独对象操作是线程安全的，调用过程中不需要额外的保障措施，但是涉及到某些业务场景需要特定顺序连续调用，就可能需要调用者考虑使用额外的同步手段保证同步。引用《深入理解Java虚拟机》一书中的例子很能说明问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">private static Vector&lt;Integer&gt; vector &#x3D; new Vector&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">public static void main(String\[\] args)&#123;</span><br><span class="line">    while(true)&#123;</span><br><span class="line">        for(int i &#x3D; 0; i&lt;10; i++)&#123;</span><br><span class="line">            vector.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;一个线程删数据</span><br><span class="line">    Thread removeThread &#x3D; new Thread(new Runnable()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            for(int i&#x3D;0 ; i&lt;vector.size() ;i++)&#123;</span><br><span class="line">                vector.remove(i);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;一个线程读数据</span><br><span class="line">    Thread printThread &#x3D; new Thread(new Runnable() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run()&#123;</span><br><span class="line">            for(int i&#x3D;0 ; i&lt;vector.size() ;i++)&#123;</span><br><span class="line">                System.out.println(vector.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    removeThread.start();</span><br><span class="line">    printThread.start();</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;防止过多线程，内存溢出</span><br><span class="line">    while(Thread.activeCount() &gt; 20);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line">运行报错：</span><br><span class="line"></span><br><span class="line">    java.lang.ArrayIndexOutOfBoundsException</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">虽然说Vector已经是Java中所谓的“线程安全”了，但是在这种特殊的情况下，无法保证正确的输出结果。这里就需要做一些额外的同步手段，如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Thread removeThread = new Thread(new Runnable(){<br>    @Override<br>    public void run(){<br>        synchronized (vector){<br>            for(int i=0 ; i&lt;vector.size() ;i++){<br>                vector.remove(i);<br>            }<br>        }<br>    }<br>});</p>
<p>//一个线程读数据<br>Thread printThread = new Thread(new Runnable() {<br>    @Override<br>    public void run(){<br>        synchronized (vector){<br>            for(int i=0 ; i&lt;vector.size() ;i++){<br>                System.out.println(vector.get(i));<br>            }<br>        }<br>    }<br>});</p>
<p>```
 </p>
<h1 id="Java中的互斥同步"><a href="#Java中的互斥同步" class="headerlink" title="Java中的互斥同步"></a>Java中的互斥同步</h1><h2 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h2><p>说到线程安全，离不开讨论锁的实现方式。说到锁，Java开发者们第一想到的肯定是Synchronized关键字，我们就先从这个关键字切入，来阐述Java中锁的实现。</p>
<h4 id="同步原理"><a href="#同步原理" class="headerlink" title="同步原理"></a><em>同步原理</em></h4><blockquote>
<p>JVM规范规定JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明，但是方法的同步同样可以使用这两个指令来实现。monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处， JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个 monitor 与之关联，当且一个monitor 被持有后，它将处于锁定状态。线程执行到 monitorenter 指令时，将会尝试获取对象所对应的 monitor 的所有权，即尝试获得对象的锁。</p>
</blockquote>
<p>Sychronized采取的同步策略是互斥同步，怎么理解互斥同步呢？通常情况下，临界区（Critical Section）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现形式。在每次获取资源之前，都需要检查是否有线程占用该资源。 这里有两个关键点需要注意：</p>
<ul>
<li>Sychronized是可重入的；</li>
<li>已经进入的线程尚未执行完，将会阻塞后面其他线程；</li>
</ul>
<h4 id="锁的本质是对象实例"><a href="#锁的本质是对象实例" class="headerlink" title="锁的本质是对象实例"></a><em>锁的本质是对象实例</em></h4><p>对于非静态方法来说，Synchronized 有两种呈现形式，Synchronized方法体和Synchronized语句块。两种呈现形式本质上的锁都是对象实例。 来看看代码实现</p>
<p>package org.leon.concurent;</p>
<p>public class SynchronizeDemo {</p>
<pre><code>static SynchronizeDemo synchronizeDemo = new SynchronizeDemo();

public static void main(String\[\] args) &#123;
    Thread t1 = new Thread(synchronizeDemo::doSth1);
    Thread t2 = new Thread(synchronizeDemo::doSth1);
    t1.start();
    t2.start();
&#125;

public void doSth1() &#123;
    /\*\*
     \* 锁对象实例 synchronizeDemo
     */
    synchronized (synchronizeDemo)&#123;
        try &#123;
            System.out.println(&quot;正在执行方法&quot;);
            Thread.sleep(10000);
            System.out.println(&quot;正在退出方法&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

public void doSth2() &#123;
    /\*\*
     \* 锁对象实例 this 等同于 synchronizeDemo
     */
    synchronized (this)&#123;
        try &#123;
            System.out.println(&quot;正在执行方法&quot;);
            Thread.sleep(10000);
            System.out.println(&quot;正在退出方法&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

public synchronized void doSth3() &#123;
    /\*\*
     \*  表面呈现是锁方法体，实际上是synchronized (this) ，等价于上面
     */
    try &#123;
        System.out.println(&quot;正在执行方法&quot;);
        Thread.sleep(10000);
        System.out.println(&quot;正在退出方法&quot;);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre>
<p>}</p>
<p>那么对于静态方法来说锁定的又是什么呢？</p>
<p>package org.leon.concurent;</p>
<p>public class SynchronizeDemo {</p>
<pre><code>public static void main(String\[\] args) &#123;
    Thread t1 = new Thread(SynchronizeDemo::doSth1);
    Thread t2 = new Thread(SynchronizeDemo::doSth1);
    t1.start();
    t2.start();
&#125;
/\*\*
 \* 锁定Synchronized 的Class对象
 */
public static void doSth1() &#123;
    synchronized (SynchronizeDemo.class)&#123;
        try &#123;
            System.out.println(&quot;正在执行方法&quot;);
            Thread.sleep(10000);
            System.out.println(&quot;正在退出方法&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

/\*\*
 \* 锁定当前类的Class对象，所以和上边等价
 */
public synchronized static void doSth2() &#123;
    try &#123;
        System.out.println(&quot;正在执行方法&quot;);
        Thread.sleep(10000);
        System.out.println(&quot;正在退出方法&quot;);
    &#125; catch (InterruptedException e) &#123;
        e.printStackTrace();
    &#125;
&#125;</code></pre>
<p>}</p>
<p>我们可以看出，从本质上而非呈现形式上看，synchronized同步也分两种。</p>
<ul>
<li>锁类的对象实例，针对于某个具体实例普通方法/语句块的互斥；</li>
<li>锁类的Class对象，针对于Class类静态方法/语句块的互斥；</li>
</ul>
<h4 id="进程切换导致的系统开销"><a href="#进程切换导致的系统开销" class="headerlink" title="进程切换导致的系统开销"></a><em>进程切换导致的系统开销</em></h4><p>Java的线程是直接映射到操作系统线程之上的，线程的挂起、阻塞、唤醒等都需要操作系统的参与，因此在线程切换的过程中是有一定的系统开销的。在多线程环境下调用Synchronized方法，有可能需要多次线程状态切换，因此可以说Synchronized是在Java语言中一个重量级操作。 虽然如此，JDK1.6版本后还是对Synchronized关键字做了相关优化，加入锁自旋特性减少系统线程切换导致的开销，几乎与ReentrantLock的性能不相上下，因此建议在能满足业务需求的前提下，优先使用Sychronized。</p>
<h2 id="ReentrantLock-可重入锁"><a href="#ReentrantLock-可重入锁" class="headerlink" title="ReentrantLock (可重入锁)"></a>ReentrantLock (可重入锁)</h2><p>与Synchronized的实现原理类似，采用的都是互斥同步策略，用法和实现效果上来说也很相似，也具备可重入的特性。 不同点是，Sychronized是原生语法层面上同步控制，其颗粒度更大；相比而言，ReentranLock是从API层面来控制锁（lock()与unlock()方法），开发者的自主权更强，可控制粒度更细，优化空间更高。</p>
<h4 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a><em>高级特性</em></h4><p>这里可以直接引用《深入理解Java虚拟机》的描述</p>
<blockquote>
<ul>
<li>等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。Sychronized的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带boolean值的构造函数要求使用公平锁；</li>
<li>锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象，而在Synchronized中，锁对象的wait()和notify()或notifyAll()方法可以实现一个隐含的条件，如果要多于一个条件关联的时候，就不得不额外添加一个锁，而ReentrantLock无需这样做，只需要多次调用newCondition()方法即可。</li>
</ul>
</blockquote>
<h4 id="公平锁正确的打开方式"><a href="#公平锁正确的打开方式" class="headerlink" title="公平锁正确的打开方式"></a><em>公平锁正确的打开方式</em></h4><p>package org.leon.concurent.lock;</p>
<p>import org.junit.Test;</p>
<p>import java.util.ArrayList;<br>import java.util.Collection;<br>import java.util.Collections;<br>import java.util.List;<br>import java.util.concurrent.locks.Lock;<br>import java.util.concurrent.locks.ReentrantLock;</p>
<p>/**<br> * 公平锁和非公平锁区别<br> *<br> * Created by LeonWong on 16/4/28.<br> */<br>public class FairAndUnfairTest {</p>
<pre><code>private static Lock fairLock = new ReentrantLockRev(true);
private static Lock unfairLock = new ReentrantLockRev(false);

@Test
public void fair() &#123;
    testLock(fairLock);
&#125;

@Test
public void unfair() &#123;
    testLock(unfairLock);
&#125;

/\*\*
 \* 启动十个Job
 \*
 \* @param lock
 */
private void testLock(Lock lock) &#123;
    for (int i = 0; i &lt; 10; i++) &#123;
        new Thread(new Job(lock), &quot;Thread-&quot; + i).start();
    &#125;
&#125;

private static class Job extends Thread &#123;
    private Lock lock;

    public Job(Lock lock) &#123;
        this.lock = lock;
    &#125;

    @Override
    public void run() &#123;
        lock.lock();
        try &#123;
            // 连续多次打印当前Tread和队列中的Thread
            for (int i = 0; i &lt; 6; i++) &#123;
                System.out.println(&quot;Lock by \[&#39;&quot; + Thread.currentThread().getName() + &quot;&#39;\]&quot;);
            &#125;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;

private static class ReentrantLockRev extends ReentrantLock &#123;
    public ReentrantLockRev(boolean fair) &#123;
        super(fair);
    &#125;

    // 颠倒列表顺序
    public Collection&lt;Thread&gt; getQueuedThreads() &#123;
        List&lt;Thread&gt; threads = new ArrayList&lt;Thread&gt;(super.getQueuedThreads());
        Collections.reverse(threads);
        return threads;
    &#125;
&#125;</code></pre>
<p>}</p>
<p> </p>
<p>可以发现，使用非公平锁的时候，打印出来的线程名称顺序是乱的；而使用公平锁后，线程名称显示顺序则是按照先进先出的原则打印出来。</p>
<h4 id="绑定条件-–-Condition用法"><a href="#绑定条件-–-Condition用法" class="headerlink" title="绑定条件 – Condition用法"></a><em>绑定条件 – Condition用法</em></h4><p>在jdk1.5以前，线程的等待与唤醒功能，只能通过执行Object自带的notify()和wait()方法实现。来看个简单的栗子</p>
<p>package org.leon.concurent.volatileUsage;</p>
<p>import org.junit.Test;<br>import org.leon.concurent.SleepUtils;</p>
<p>import java.text.SimpleDateFormat;<br>import java.util.Date;</p>
<p>public class WaitAndNotifyDemo {</p>
<pre><code>// 内存可见
private static volatile boolean flag = true;

private static final Object lock = new Object();

@Test
public void doLauncher() throws Exception &#123;
    Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);
    waitThread.start();
    SleepUtils.sleepForSecond(1);
    Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);
    notifyThread.start();
    // 防止主线程关闭后导致子线程关闭
    SleepUtils.sleepForSecond(1000000);
&#125;

private static class Wait implements Runnable &#123;
    @Override
    public void run() &#123;
        // 加锁,拥有lock的Monitor
        synchronized (lock) &#123;
            // 当条件不满足时,继续wait,同时释放了lock的锁
            while (flag) &#123;
                try &#123;
                    System.out.println(Thread.currentThread() + &quot; flag is true. wait @ &quot;
                            \+ new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                    lock.wait();
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                System.out.println(Thread.currentThread() + &quot; Thread has been woke!!!!. wait @ &quot;
                        \+ new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            &#125;
            // 条件满足,完成工作
            System.out.println(Thread.currentThread() + &quot; flag is false. done!!! @ &quot;
                    \+ new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
        &#125;
    &#125;
&#125;

private static class Notify implements Runnable &#123;
    @Override
    public void run() &#123;
        // 加锁,拥有lock的Monitor
        synchronized (lock) &#123;
            // 获取lock的锁,然后进行通知,通知时不会释放lock的锁
            // 直到当前线程释放了lock后,waitThread才能从wait方法中返回
            System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot;
                    \+ new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            System.out.println(Thread.currentThread() + &quot; do notifyAll,but I wanna sleep 4 5 secs. notify @ &quot;
                    \+ new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            lock.notifyAll();
            flag = false;
            SleepUtils.sleepForSecond(5);
        &#125;
        // 再次加锁
        synchronized (lock) &#123;
            System.out.println(Thread.currentThread() + &quot; hold lock another 5 secs and. notify @ &quot;
                    \+ new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            SleepUtils.sleepForSecond(5);
        &#125;
    &#125;
&#125;</code></pre>
<p>}</p>
<p>这里要注意的是，执行wait()方法后，线程进入等待状态，并且释放了锁，等待其他线程执行notify()方法将其唤醒。 而Condition的用法与其极其类似，先是从Lock对象中执行newCondition()实例化Condition对象，且允许实例化多个。通过调用await()和notify()方法完成等待唤醒一系列操作，来看个有界阻塞队列的实现。</p>
<p>package org.leon.concurent.condition;</p>
<p>import java.util.concurrent.locks.Condition;<br>import java.util.concurrent.locks.Lock;<br>import java.util.concurrent.locks.ReentrantLock;</p>
<p>/**<br> * 有界阻塞队列<br/><br> * 当队列为空,队列将会阻塞删除并获取操作的线程,直到队列中有新元素;<br/><br> * 当队列已满,队列将会阻塞添加操作的线程，直到队列有空位置；<br> * <p><br> * Created by LeonWong on 16/4/29.<br> */<br>public class BoundedQueue<T> {<br>    private Object[] items;</p>
<pre><code>// 添加的下标,删除的下标和数组当前数量
private int addIndex, removeIndex, count;
private Lock lock = new ReentrantLock();
private Condition notEmpty = lock.newCondition();
private Condition notFull = lock.newCondition();

public BoundedQueue() &#123;
    items = new Object\[5\];
&#125;

public BoundedQueue(int size) &#123;
    items = new Object\[size\];
&#125;

/\*\*
 \* 添加一个元素,数组满则添加线程进入等待状态
 \*
 \* @param t
 \* @throws InterruptedException
 */
public void add(T t) throws InterruptedException &#123;
    lock.lock();
    try &#123;
        while (items.length == count) &#123;
            System.out.println(&quot;添加队列--陷入等待&quot;);
            notFull.await();
        &#125;
        items\[addIndex\] = t;
        addIndex = ++addIndex == items.length ? 0 : addIndex;
        count++;
        notEmpty.signal();
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;

/\*\*
 \* 删除并获取一个元素,数组空则进入等待
 \*
 \* @return
 \* @throws InterruptedException
 */
public T remove() throws InterruptedException &#123;
    lock.lock();
    try &#123;
        while (count == 0) &#123;
            System.out.println(&quot;删除队列--陷入等待&quot;);
            notEmpty.await();
        &#125;
        Object tmp = items\[removeIndex\];
        items\[removeIndex\] = null;// 这一步可以有可无
        removeIndex = ++removeIndex == items.length ? 0 : removeIndex;
        count--;
        notFull.signal();
        return (T) tmp;
    &#125; finally &#123;
        lock.unlock();
    &#125;
&#125;

public Object\[\] getItems() &#123;
    return items;
&#125;

public void setItems(Object\[\] items) &#123;
    this.items = items;
&#125;

public int getAddIndex() &#123;
    return addIndex;
&#125;

public void setAddIndex(int addIndex) &#123;
    this.addIndex = addIndex;
&#125;

public int getRemoveIndex() &#123;
    return removeIndex;
&#125;

public void setRemoveIndex(int removeIndex) &#123;
    this.removeIndex = removeIndex;
&#125;

public int getCount() &#123;
    return count;
&#125;

public void setCount(int count) &#123;
    this.count = count;
&#125;</code></pre>
<p>}</p>
<p> </p>
<p>测试用例</p>
<p>package org.leon.concurent.condition;</p>
<p>import org.junit.Test;<br>import org.leon.concurent.SleepUtils;</p>
<p>public class BoundedQueueTest {</p>
<pre><code>/\*\*
 \* 队列初始化size为10
 */
private BoundedQueue&lt;String&gt; boundedQueue = new BoundedQueue&lt;&gt;(10);

@Test
public void testBoundedQueue() throws InterruptedException &#123;
    // 删除队列,起初队列为空,务必陷入等待
    new Thread(new DoRemove()).start();

    SleepUtils.sleepForSecond(2);

    // 添加11条数据入队,队列“有可能”会满,并陷入等待
    for (int i = 0; i &lt; 11; i++) &#123;
        new Thread(new DoAdd()).start();
    &#125;

    System.out.println(&quot;添加队列完毕&quot;);
    SleepUtils.sleepForSecond(4);

    // 再删一次
    boundedQueue.remove();

    SleepUtils.sleepForSecond(2);

    System.out.println(&quot;操作完毕,其中addIndex为&quot; + boundedQueue.getAddIndex() + &quot;,removeIndex为&quot;
            \+ boundedQueue.getRemoveIndex() + &quot;,count为&quot; + boundedQueue.getCount());
&#125;

private class DoRemove implements Runnable &#123;
    @Override
    public void run() &#123;
        try &#123;
            boundedQueue.remove();
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;

private class DoAdd implements Runnable &#123;
    @Override
    public void run() &#123;
        try &#123;
            boundedQueue.add(&quot;Something&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;</code></pre>
<p>}</p>
<h4 id="AbstractQueuedSynchronizer（简称AQS）"><a href="#AbstractQueuedSynchronizer（简称AQS）" class="headerlink" title="AbstractQueuedSynchronizer（简称AQS）"></a><em>AbstractQueuedSynchronizer（简称AQS）</em></h4><p>ReentrantLock实现是基于AQS这个抽象方法的，然而篇幅有限，将在下一篇文章里从代码的角度着重探讨。 简单来说，AQS是通过管理状态的方式来实现相对线程安全的。Java中信号量（Semaphore）、读写锁（ReadWriteLock）、计数器（CountDownLatch）以及FutureTask等都是基于AQS实现的，可见这个抽象类的地位多么不一般。</p>
<h4 id="与其说ReentrantLock性能更好不如说Synchronized优化空间更大"><a href="#与其说ReentrantLock性能更好不如说Synchronized优化空间更大" class="headerlink" title="与其说ReentrantLock性能更好不如说Synchronized优化空间更大"></a><em>与其说ReentrantLock性能更好不如说Synchronized优化空间更大</em></h4><p>上面介绍过，Synchronized在JDK1.6以后性能有所增强，因此在能满足业务复杂度需求的情况下，采用Synchronized也未尝不可。然而互斥同步终究属于悲观的并发策略，在对性能要求极高的业务场景下使用以上互斥同步策略并不合适。接下来进而介绍如何实现乐观的同步策略。</p>
<h2 id="Java中的非阻塞同步策略"><a href="#Java中的非阻塞同步策略" class="headerlink" title="Java中的非阻塞同步策略"></a>Java中的非阻塞同步策略</h2><h4 id="CAS指令与原子性"><a href="#CAS指令与原子性" class="headerlink" title="CAS指令与原子性"></a><em>CAS指令与原子性</em></h4><p>原子操作的业务表现形式是“不可被中断或不可被分割操作”。所谓CAS（Compare And Swap）比较并交换就是一种原子操作。简单来说执行CAS需要两个参数，一个新值，一个旧值，当比较内存的值与旧值相符时，则替换为新值，否则不执行替换操作。CPU如何实现，这里不多说，Java若要实现CAS则需要CPU指令集配合，JDK1.5加入了这个特性，并在随后的版本对其进行丰富。</p>
<p>package org.leon.concurent.atomic;</p>
<p>import org.junit.Test;</p>
<p>import java.util.concurrent.atomic.AtomicInteger;</p>
<p>/**<br> * Created by LeonWong on 16/6/10.<br> */<br>public class AtomicItegerUpdaterTest {<br>    private static AtomicInteger couter = new AtomicInteger(0);</p>
<pre><code>@Test
public void doUpdate() &#123;
    couter.compareAndSet(0, 1);
    System.out.println(&quot;结果为&quot; + couter.get());// 结果为1
    couter.compareAndSet(0, 3);
    System.out.println(&quot;结果为&quot; + couter.get());// 结果为1
&#125;</code></pre>
<p>}</p>
<p>除了Integer以外，还支持包括CAS更新实例、更新实例的属性等功能。 阅读源码不难发现，Java是通过一个sun.misc.Unsafe的类，完成CAS指令操作的，然而我们从AQS的源码中也发现了sun.misc.Unsafe类的踪影。</p>
<p>/**<br> * Atomically sets synchronization state to the given updated<br> * value if the current state value equals the expected value.<br> * This operation has memory semantics of a {@code volatile} read<br> * and write.<br> *<br> * @param expect the expected value<br> * @param update the new value<br> * @return {@code true} if successful. False return indicates that the actual<br> *         value was not equal to the expected value.<br> */<br>protected final boolean compareAndSetState(int expect, int update) {<br>    // See below for intrinsics setup to support this<br>    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);<br>}</p>
<p> </p>
<p>其实不难理解，AQS负责管理状态（也可以理解为互斥资源）—— 这里狭义来说可以是锁是否被线程占用的标记，当然，状态的判定规则以及互斥资源数目由AQS的继承者们负责实现，而状态的更新只能是通过CAS指令完成，以确保线程安全。</p>
<h2 id="volatile-关键字"><a href="#volatile-关键字" class="headerlink" title="volatile 关键字"></a>volatile 关键字</h2><p>volatile在多线程环境下保证了共享变量内存可见性。意思就是线程A修改了volatile修饰的共享变量，线程B能够感知修改。如果volatile合理使用的话，将会比Synchronized的执行成本更低。 从底层的角度来说，为了提高处理速度，CPU不直接和内存进行通信，而是先将数据读入到CPU缓存后在进行操作，但不知何时将会更新到内存。声明变量加入volatile关键字后，每次修改该变量，JVM就会通知处理器将CPU缓存内的值强制更新到内存中，这就是所谓的“可见性”。再来看代码。</p>
<p>package org.leon.concurent.volatileUsage;</p>
<p>/**<br> * VolatileDemo 与 SynchronizedDemo 实现效果等价<br> *<br> * Created by LeonWong on 16/6/10.<br> */<br>public class VolatileDemo {<br>    volatile long vl = 0L;</p>
<pre><code>public void set(long l) &#123;
    vl = l;
&#125;

public void getAndIncrement() &#123;
    vl++;
&#125;

public long get() &#123;
    return vl;
&#125;</code></pre>
<p>}</p>
<p>class SynchronizedDemo {<br>    long vl = 0L;</p>
<pre><code>public synchronized void set(long l) &#123;
    vl = l;
&#125;

public void getAndIncrement() &#123;
    long temp = get();
    temp += 1L;
    set(temp);
&#125;

public synchronized long get() &#123;
    return vl;
&#125;</code></pre>
<p>}</p>
<h2 id="无同步策略"><a href="#无同步策略" class="headerlink" title="无同步策略"></a>无同步策略</h2><p>这就比较容易理解了，同步只是线程安全的一个手段，无同步并不意味着线程不安全。大致两种方法的代码可以保证没有使用同步方案的前提下的线程安全。</p>
<ul>
<li>可重入代码。例如纯计算的函数之类的，方法运行间不需要获取外部资源就可以进行计算。</li>
<li>线程本地存储资源。很好理解，线程本地维护自己的资源，根本不存在与其他线程资源冲突的可能。</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/JAVA/" rel="tag"><i class="fa fa-tag"></i> JAVA</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2017/06/17/zookeeper%E7%AE%80%E4%BB%8B/" rel="prev" title="ZooKeeper简介">
      <i class="fa fa-chevron-left"></i> ZooKeeper简介
    </a></div>
      <div class="post-nav-item">
    <a href="/2017/06/18/hashmap%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/" rel="next" title="HashMap的工作原理">
      HashMap的工作原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">1.</span> <span class="nav-text">线程安全</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="nav-number">3.</span> <span class="nav-text">Java的线程安全</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5"><span class="nav-number"></span> <span class="nav-text">Java中的互斥同步</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Synchronized"><span class="nav-number">1.</span> <span class="nav-text">Synchronized</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86"><span class="nav-number">1.0.1.</span> <span class="nav-text">同步原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E5%AF%B9%E8%B1%A1%E5%AE%9E%E4%BE%8B"><span class="nav-number">1.0.2.</span> <span class="nav-text">锁的本质是对象实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80"><span class="nav-number">1.0.3.</span> <span class="nav-text">进程切换导致的系统开销</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ReentrantLock-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="nav-number">2.</span> <span class="nav-text">ReentrantLock (可重入锁)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="nav-number">2.0.1.</span> <span class="nav-text">高级特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F"><span class="nav-number">2.0.2.</span> <span class="nav-text">公平锁正确的打开方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%91%E5%AE%9A%E6%9D%A1%E4%BB%B6-%E2%80%93-Condition%E7%94%A8%E6%B3%95"><span class="nav-number">2.0.3.</span> <span class="nav-text">绑定条件 – Condition用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AbstractQueuedSynchronizer%EF%BC%88%E7%AE%80%E7%A7%B0AQS%EF%BC%89"><span class="nav-number">2.0.4.</span> <span class="nav-text">AbstractQueuedSynchronizer（简称AQS）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8E%E5%85%B6%E8%AF%B4ReentrantLock%E6%80%A7%E8%83%BD%E6%9B%B4%E5%A5%BD%E4%B8%8D%E5%A6%82%E8%AF%B4Synchronized%E4%BC%98%E5%8C%96%E7%A9%BA%E9%97%B4%E6%9B%B4%E5%A4%A7"><span class="nav-number">2.0.5.</span> <span class="nav-text">与其说ReentrantLock性能更好不如说Synchronized优化空间更大</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E4%B8%AD%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="nav-number">3.</span> <span class="nav-text">Java中的非阻塞同步策略</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#CAS%E6%8C%87%E4%BB%A4%E4%B8%8E%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="nav-number">3.0.1.</span> <span class="nav-text">CAS指令与原子性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-number">4.</span> <span class="nav-text">volatile 关键字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E7%AD%96%E7%95%A5"><span class="nav-number">5.</span> <span class="nav-text">无同步策略</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="FengQiang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">FengQiang</p>
  <div class="site-description" itemprop="description">面向接口编程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">93</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">19</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">30</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/merlinfeng" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;merlinfeng" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:feng_qiang@yeah.net" title="E-Mail → mailto:feng_qiang@yeah.net" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2015 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">merlinfeng</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : 'e5b1ece2c63bbcdfef53',
      clientSecret: 'ea304fd40315409bd27d44f3c44ed773e6edce9b',
      repo        : 'gitment-comments',
      owner       : 'merlinfeng',
      admin       : ['merlinfeng'],
      id          : 'd1c4f632a6604fc6ffd549d17c39ca0e',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

</body>
</html>
